{% extends "mosaic/mosaic_base" %}
{% import "macros" as macros %}

{% block body %}
    {{ super() }}
    {{ macros::mosaic(rows=rows) }}
    <div class="block"></div>
    {{ macros::mosaic(rows=rows2) }}
    <div class="block"></div>
    <section class="section paddingless">
        <div class="buttons is-flex is-justify-content-center">
            {% if base.is_admin %}
                <a class="button is-danger" href="/mosaic/reset">
                    Reset All
                </a>
            {% endif %}
            <a class="button is-danger" href="/mosaic/reset-me">
                Reset Mine
            </a>
        </div>
    </section>
    <div class="block"></div>
    <script>
        const user = {{ base.user.id }};

        const darkColors = {
            "Red": "#570100",
            "Green": "#003810",
            "Blue": "#000053",
            "Yellow": "#4e3c00",
            "White": "#3b3b3b",
            "Orange": "#583602",
        }
        const brightColors = {
            "Red": "#ff0700",
            "Green": "#00fa45",
            "Blue": "#0400ff",
            "Yellow": "#ffd200",
            "White": "#ffffff",
            "Orange": "#ff8000",
        }

        let rows = document.getElementsByClassName("mosaic-grid")[0].children;
        let rows2 = document.getElementsByClassName("mosaic-grid")[1].children;

        const White = "White";
        const Yellow = "Yellow";
        const Green = "Green";
        const Blue = "Blue";
        const Orange = "Orange";
        const Red = "Red";

        let data = [
            {% for x in initial_data %}
            {
                "row": {{ x.row }},
                "col": {{ x.col }},
                "user": {% if x.user %}{{ x.user }}{% else %}null{% endif %},
                "colors": {{ x.colors }},
            },
            {% endfor %}
        ];

        async function fetchAndUpdate() {
            let new_data = await (await fetch("/api/mosaic/tiles")).json();
            await update(new_data, false);
        }

        async function update(new_data, force_update) {
            for (let new_tile of new_data) {
                let found_identical = false;
                for (let old_tile of data) {
                    if (new_tile === old_tile) {
                        found_identical = true;
                        break;
                    }
                }
                if (!found_identical || force_update) {
                    let e1 = rows[new_tile.row].children[new_tile.col];
                    for (let y = 0; y < 3; y++) {
                        for (let x = 0; x < 3; x++) {
                            if (new_tile.user === user) {
                                e1.children[y].children[x].style.backgroundColor = brightColors[new_tile.colors[y][x]]
                            } else {
                                e1.children[y].children[x].style.backgroundColor = darkColors[new_tile.colors[y][x]]
                            }
                        }
                    }
                    let e2 = rows2[new_tile.row].children[new_tile.col].children[0].children[0];
                    if (new_tile.user === user) {
                        e2.style.backgroundColor = brightColors["Green"];
                    } else if (new_tile.user == null) {
                        e2.style.backgroundColor = "grey";
                    } else {
                        e2.style.backgroundColor = brightColors["Red"];
                    }
                }
            }
            data = new_data;
        }

        async function reloadDataAlways() {
            await fetchAndUpdate();
            setTimeout(reloadDataAlways, 1000);
        }

        document.addEventListener('DOMContentLoaded', () => {
            for (let row = 0; row < rows.length; row++) {
                let cells = rows[row].children;
                let cells2 = rows2[row].children;
                for (let cell = 0; cell < cells.length; cell++) {
                    cells[cell].addEventListener("click", () => {
                        fetch(`/api/mosaic/claim/` + row + "/" + cell, {method: 'POST'}).then(fetchAndUpdate);
                    });
                    cells2[cell].addEventListener("click", () => {
                        fetch(`/api/mosaic/claim/` + row + "/" + cell, {method: 'POST'}).then(fetchAndUpdate);
                    });
                }
            }

            update(data, true);
            reloadDataAlways();
        });
    </script>
{% endblock body %}
